<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Mystic Tarot - Mobile Lite</title>
    <style>
        /* ================= CSS æ ·å¼ (ä¿æŒè§†è§‰æ•ˆæœ) ================= */
        :root {
            --gold: #ffd700;
            --gold-glow: rgba(255, 215, 0, 0.5);
            --bg-dark: #050510; /* æ”¹ç”¨çº¯è‰²èƒŒæ™¯+ç²’å­ï¼Œå‡å°‘æ¸å˜æ¸²æŸ“å¼€é”€ */
        }

        body { margin: 0; overflow: hidden; background: var(--bg-dark); font-family: 'Noto Sans SC', sans-serif; color: white; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 60; pointer-events: none; }
        
        .hud { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: auto; }
        .btn-group { display: flex; gap: 10px; }

        .badge { 
            background: rgba(20, 20, 35, 0.8); 
            border: 1px solid rgba(255, 215, 0, 0.3); 
            color: var(--gold); 
            padding: 8px 16px; 
            border-radius: 50px; 
            font-size: 12px; 
            display: flex; align-items: center; gap: 6px; 
            backdrop-filter: blur(5px);
        }

        .status-dot { width: 8px; height: 8px; background: #555; border-radius: 50%; transition: 0.3s; }
        .status-dot.active { background: #00ffaa; box-shadow: 0 0 10px #00ffaa; }

        /* --- æ¨¡å¼é€‰æ‹© --- */
        #mode-selection {
            position: absolute; inset: 0;
            background: rgba(5, 5, 16, 0.95);
            z-index: 50;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: 0.3s;
            pointer-events: auto;
        }
        #mode-selection.hidden { opacity: 0; pointer-events: none; transform: scale(1.1); }
        
        .mode-title { color: var(--gold); font-size: 22px; letter-spacing: 3px; margin-bottom: 30px; text-shadow: 0 0 10px var(--gold-glow); }
        .mode-container { display: flex; flex-direction: column; gap: 15px; width: 80%; max-width: 300px; }
        
        .mode-card {
            background: rgba(30,30,40,0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            text-align: left;
            position: relative;
        }
        .mode-card:active { background: rgba(50,50,60,0.9); transform: scale(0.98); }
        .mode-card h3 { color: var(--gold); margin: 0 0 5px 0; font-size: 16px; }
        .mode-card p { font-size: 12px; color: #aaa; margin: 0; }

        /* --- ç»“æœå±•ç¤ºé¢æ¿ --- */
        #result-overlay {
            position: absolute; inset: 0;
            background: rgba(5,5,10,0.98);
            z-index: 100;
            display: none; flex-direction: column; 
            padding: 30px 20px; overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* iOS æ»šåŠ¨ä¼˜åŒ– */
        }
        #result-overlay.active { display: flex; animation: fadeIn 0.5s ease; }
        
        .result-header { text-align: center; margin-bottom: 30px; border-bottom: 1px solid rgba(255,215,0,0.2); padding-bottom: 15px; }
        .result-header h2 { color: var(--gold); font-size: 24px; margin: 0; }
        
        .cards-spread { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 30px; }
        .mini-card { width: 90px; text-align: center; animation: slideUp 0.5s ease backwards; }
        .mini-card img { width: 100%; border-radius: 6px; margin-bottom: 5px; border: 1px solid #333; }
        .mini-card .pos-label { font-size: 10px; color: var(--gold); }
        .mini-card .name-label { font-size: 10px; color: #fff; }

        .interpretation-box { padding-bottom: 50px; }
        .interp-section { margin-bottom: 25px; }
        .interp-title { color: #eebbff; font-size: 15px; margin-bottom: 8px; font-weight: bold; }
        .interp-content { font-size: 14px; line-height: 1.6; color: #ccc; }
        
        .restart-btn {
            display: block; margin: 30px auto; padding: 12px 40px;
            background: transparent; border: 1px solid var(--gold); color: var(--gold);
            border-radius: 50px; font-size: 14px;
        }

        /* --- 3Dåœºæ™¯å±‚ --- */
        #video-container { position: absolute; top: 60px; right: 20px; width: 120px; height: 160px; border-radius: 8px; overflow: hidden; opacity: 0; pointer-events: none; transition: 0.5s; z-index: 5; }
        #video-container.active { opacity: 0.8; }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* --- 2Då¡ç‰Œå±•ç¤º (é€‚é…æ‰‹æœº) --- */
        .modal-card-img {
            /* é€‚é…æ‰‹æœºå±å¹•ï¼šæœ€å¤§å®½åº¦é™åˆ¶ï¼Œé«˜åº¦è‡ªé€‚åº” */
            max-width: 80vw;
            max-height: 60vh;
            height: auto;
            border-radius: 10px;
            border: 2px solid var(--gold);
            box-shadow: 0 0 30px var(--gold-glow);
            margin-bottom: 20px;
            animation: cardAppear 0.5s ease-out forwards;
        }
        
        @keyframes cardAppear { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        #card-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; text-align: center; pointer-events: none; z-index: 20;
        }
        #card-modal.active { pointer-events: auto; }
        #card-modal h2 { margin: 0 0 5px 0; color: var(--gold); font-size: 24px; text-shadow: 0 0 10px var(--gold-glow); }
        #card-modal p { font-size: 13px; color: #ddd; margin: 0; }

        #loading { position: fixed; inset: 0; background: #020205; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; transition: 0.5s; }
        .spinner { width: 40px; height: 40px; border: 2px solid rgba(255,215,0,0.1); border-top-color: var(--gold); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        #hint { position: absolute; top: 55%; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 12px; letter-spacing: 2px; pointer-events: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

<div id="loading">
    <div class="spinner"></div>
    <p id="loading-txt" style="margin-top: 20px; color: #ffd700; font-size: 12px;">èµ„æºåŠ è½½ä¸­...</p>
</div>

<div id="mode-selection" class="hidden">
    <div class="mode-title">é€‰æ‹©å¯ç¤ºæ¨¡å¼</div>
    <div class="mode-container">
        <div class="mode-card" onclick="selectMode(1)">
            <h3>âœ¨ æ¯æ—¥ä¸€æŠ½ (1å¼ )</h3>
            <p>ä»Šæ—¥æŒ‡å¼• / çµæ„Ÿè§‰å¯Ÿ</p>
        </div>
        <div class="mode-card" onclick="selectMode(3)">
            <h3>â³ ç»å…¸ä¸‰ç‰Œé˜µ (3å¼ )</h3>
            <p>è¿‡å» Â· ç°åœ¨ Â· æœªæ¥</p>
        </div>
        <div class="mode-card" onclick="selectMode(5)">
            <h3>âš–ï¸ å†³ç­–å¯¹æ¯” (5å¼ )</h3>
            <p>å²”è·¯å£çš„æŠ‰æ‹©åˆ†æ</p>
        </div>
    </div>
</div>

<div id="result-overlay">
    <div class="result-header">
        <h2>æ˜Ÿç•Œå¯ç¤ºå½•</h2>
        <p id="result-mode-name">Reading</p>
    </div>
    <div class="cards-spread" id="result-cards"></div>
    <div class="interpretation-box" id="result-text"></div>
    <button class="restart-btn" onclick="resetApp()">å†æ¬¡æé—®</button>
</div>

<div id="ui-layer">
    <div class="hud">
        <div class="btn-group">
            <div class="badge" id="btn-cam">ğŸ“· å¯åŠ¨</div>
            <div class="badge" id="btn-full">â›¶ å…¨å±</div>
        </div>
        <div class="badge">
            <div class="status-dot" id="hand-dot"></div>
            <span id="gesture-txt">ç­‰å¾…...</span>
        </div>
    </div>

    <div id="card-modal"></div>
    <div id="hint" style="opacity: 0">ğŸ‘Œ æä½ç‰Œä¿æŒ (Hold)</div>
</div>

<div id="video-container">
    <video id="webcam" playsinline webkit-playsinline muted></video>
</div>

<script>

// --- æ•°æ®åº“ ---
const TAROT_DB = {
    "æ„šè€…": { keywords: "æ–°çš„å¼€å§‹, çº¯çœŸ, è‡ªç”±", poison: "ä¸è¦ç•æƒ§æœªçŸ¥ï¼Œä¿æŒä¸€é¢—èµ¤å­ä¹‹å¿ƒï¼Œåƒå­©å­ä¸€æ ·å»æ¢ç´¢ã€‚ä½ æ­£ç«™åœ¨æ— é™å¯èƒ½çš„èµ·ç‚¹ã€‚" },
    "é­”æœ¯å¸ˆ": { keywords: "åˆ›é€ åŠ›, æ½œèƒ½, æ˜¾åŒ–", poison: "ä½ æ‹¥æœ‰å°†æ¢¦æƒ³å˜ä¸ºç°å®çš„æ‰€æœ‰èµ„æºã€‚ç›¸ä¿¡è‡ªå·±çš„èƒ½åŠ›ï¼Œä¸“æ³¨ä½ çš„æ„å¿µï¼Œä½ æ˜¯è‡ªå·±ç”Ÿæ´»çš„åˆ›é€ è€…ã€‚" },
    // ... (ä¸ºèŠ‚çœç¯‡å¹…ï¼Œè¿™é‡Œå‡è®¾ä½ å·²ç»ä¿ç•™äº†å®Œæ•´çš„æ•°æ®åº“ï¼Œè¯·ä¿æŒåŸæœ‰çš„ TAROT_DB å†…å®¹ä¸å˜) ...
    "DEFAULT": { keywords: "æœªçŸ¥, æ¢ç´¢, å¯èƒ½æ€§", poison: "è·Ÿéšç›´è§‰ï¼Œç­”æ¡ˆå°±åœ¨é£ä¸­ã€‚" }
};

// --- é…ç½® ---
const REMOTE_PATH = "https://fastly.jsdelivr.net/gh/wormwood00/my-tarot@main/";
const BACK_IMG_URL = "https://fastly.jsdelivr.net/gh/wormwood00/my-tarot@main/1767441720.png";
const LOADING_IMG_URL = "https://fastly.jsdelivr.net/gh/wormwood00/my-tarot@main/%E5%8A%A0%E8%BD%BD%E4%B8%AD%E7%89%8C%E9%9D%A2.png";

const CONFIG = {
    spacing: 4.5, 
    pinchThreshold: 0.05, // æ‰‹æœºä¸Šæåˆè·ç¦»é˜ˆå€¼
    holdTimeRequired: 800 // æä½ä¿æŒ 800ms è§¦å‘ï¼Œæ›¿ä»£å¾€åæ‹‰
};

// --- å˜é‡ ---
let scene, camera, renderer, raycaster, handCursor, deckGroup;
let cards = [];
let mouse = new THREE.Vector2(-999, -999);
let targetMouse = new THREE.Vector2(0, 0);
let appState = 'LOADING'; 
let grabbedCard = null;
let particles = null;
let isMediaPipeReady = false;
let currentMode = 0; 
let drawnCardsList = []; 
let isFlowActive = false; 
let loadingTexture = null;
let backTexture = null;

// æ‰‹åŠ¿ç›¸å…³å˜é‡ (æ–°)
let pinchStartTime = 0;
let isPinching = false;

// ç‰¹æ®Šæ–‡ä»¶å
const SPECIAL_FILENAMES = {
    "å¥³ç¥­å¸": "å¥³ç¥­å¸-å¡”ç½—ç‰Œ.jpg",
    "å¥³çš‡": "å¥³çš‡-å¡”ç½—ç‰Œ.jpg",
    "çš‡å¸": "çš‡å¸å¡”ç½—ç‰Œç‚¹è§£.jpg",
    "æ•™çš‡": "æ•™çš‡å¡”ç½—ç‰Œ.jpg",
    "æ‹äºº": "æ‹äººå¡”ç½—ç‰Œ.jpg"
};

const MAJOR_ORDER = ["æ„šè€…","é­”æœ¯å¸ˆ","å¥³ç¥­å¸","å¥³çš‡","çš‡å¸","æ•™çš‡","æ‹äºº","æˆ˜è½¦","åŠ›é‡","éšå£«","å‘½è¿ä¹‹è½®","æ­£ä¹‰","å€’åŠäºº","æ­»ç¥","èŠ‚åˆ¶","æ¶é­”","é«˜å¡”","æ˜Ÿæ˜Ÿ","æœˆäº®","å¤ªé˜³","å®¡åˆ¤","ä¸–ç•Œ"];
const MINOR_RANKS = ["é¦–ç‰Œ", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹", "å", "ä¾ä»", "éª‘å£«", "çš‡å", "å›½ç‹"];

function getFileName(zhName) {
    return SPECIAL_FILENAMES[zhName] || (zhName + ".jpg");
}

function buildDeckPool() {
    let deck = [];
    MAJOR_ORDER.forEach(name => deck.push({ zh: name, type: 'å¤§é˜¿å¡çº³', file: getFileName(name) }));
    ["æƒæ–", "åœ£æ¯", "å®å‰‘", "æ˜Ÿå¸"].forEach(suit => {
        MINOR_RANKS.forEach(rank => {
            const name = suit + rank;
            deck.push({ zh: name, type: 'å°é˜¿å¡çº³', file: getFileName(name) });
        });
    });
    return deck;
}
const DECK_POOL = buildDeckPool();

// --- åˆå§‹åŒ–åœºæ™¯ ---
function initScene() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.02); // å¢åŠ é›¾æ°”é®æŒ¡è¿œå¤„
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.z = 24; // ç¨å¾®æ‹‰è¿œä¸€ç‚¹é€‚åº”æ‰‹æœºç«–å±

    renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" }); // å…³é—­æŠ—é”¯é½¿æå‡æ€§èƒ½
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜åˆ†å±å¡é¡¿
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const pl = new THREE.PointLight(0x8844ff, 1.5, 30);
    pl.position.set(5, 5, 10);
    scene.add(pl);

    // å‡å°‘ç²’å­æ•°é‡ (2000ä¸ªè¶³å¤Ÿäº†)
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(2000 * 3);
    for(let i=0; i<2000*3; i++) starPos[i] = (Math.random()-0.5)*150;
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0x8899aa, size: 0.2, transparent:true, opacity:0.5})));

    deckGroup = new THREE.Group();
    // ç®€åŒ–å‡ ä½•ä½“ (1,1) åˆ†æ®µ
    const cardGeo = new THREE.BoxGeometry(3.2, 4.8, 0.05); 
    
    // é¢„åŠ è½½èµ„æº
    const loader = new THREE.TextureLoader();
    
    // 1. åŠ è½½ç‰ŒèƒŒ
    loader.load(BACK_IMG_URL, (tex) => {
        tex.encoding = THREE.sRGBEncoding;
        backTexture = tex;
        // æ›´æ–°æ‰€æœ‰å¡ç‰ŒèƒŒé¢
        cards.forEach(c => { c.material[5].map = backTexture; c.material[5].needsUpdate = true; });
    });

    // 2. åŠ è½½â€œåŠ è½½ä¸­â€å ä½å›¾
    loader.load(LOADING_IMG_URL, (tex) => {
        tex.encoding = THREE.sRGBEncoding;
        loadingTexture = tex;
    });

    // åˆ›å»ºå¡ç‰Œ
    for(let i=0; i<78; i++) {
        const mats = [
            new THREE.MeshBasicMaterial({color: 0x111111}), // ä¾§é¢ç”¨ Basic æè´¨çœæ€§èƒ½
            new THREE.MeshBasicMaterial({color: 0x111111}),
            new THREE.MeshBasicMaterial({color: 0x111111}),
            new THREE.MeshBasicMaterial({color: 0x111111}),
            new THREE.MeshBasicMaterial({color: 0x000000}), // æ­£é¢é»‘åº•
            new THREE.MeshStandardMaterial({color: 0x444466, roughness: 0.6}) // èƒŒé¢ (æš‚ç”¨é¢œè‰²ï¼Œç­‰å›¾ç‰‡åŠ è½½å®Œ)
        ];
        const card = new THREE.Mesh(cardGeo, mats);
        card.position.x = (i - 78/2) * CONFIG.spacing; // å±•å¼€æ›´å®½ä¸€ç‚¹
        card.rotation.y = Math.PI; 
        card.userData = { basePos: card.position.clone(), index: i };
        deckGroup.add(card);
        cards.push(card);
    }
    scene.add(deckGroup);

    handCursor = new THREE.Mesh(
        new THREE.RingGeometry(0.4, 0.5, 16), // å‡å°‘åœ†ç¯åˆ†æ®µ
        new THREE.MeshBasicMaterial({color: 0xffd700, transparent: true, opacity: 0.8, side: THREE.DoubleSide})
    );
    scene.add(handCursor);

    raycaster = new THREE.Raycaster();
    window.addEventListener('resize', onResize);
    animate();

    setTimeout(() => { 
        document.getElementById('loading').style.opacity = 0; 
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('mode-selection').classList.remove('hidden');
        }, 500); 
    }, 1500);
}

function animate() {
    requestAnimationFrame(animate);
    
    // å¹³æ»‘é¼ æ ‡ç§»åŠ¨
    mouse.lerp(targetMouse, 0.2);
    
    // æ›´æ–°å…‰æ ‡ä½ç½®
    const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
    const dir = vector.sub(camera.position).normalize();
    const cursorDist = (appState === 'GRABBING') ? 15 : 20;
    handCursor.position.copy(camera.position.clone().add(dir.multiplyScalar(cursorDist)));
    handCursor.lookAt(camera.position);

    // ç‰Œç»„æ•´ä½“ç§»åŠ¨ (è§†å·®æ•ˆæœ)
    if (appState === 'IDLE') {
        deckGroup.position.x = THREE.MathUtils.lerp(deckGroup.position.x, -mouse.x * 120, 0.05);
    }

    raycaster.setFromCamera(mouse, camera);

    // å¡ç‰ŒåŠ¨ç”»é€»è¾‘
    for(let i=0; i<cards.length; i++) {
        const card = cards[i];
        if (card === grabbedCard) {
            if (appState === 'GRABBING') {
                const localTarget = deckGroup.worldToLocal(handCursor.position.clone());
                // å¸é™„åˆ°å±å¹•ä¸­å¿ƒ
                localTarget.x *= 0.8;
                localTarget.y *= 0.8;
                localTarget.z = card.userData.basePos.z + 14.0; // é€‚å½“æ‹‰è¿‘
                
                card.position.lerp(localTarget, 0.2);
                card.rotation.y = THREE.MathUtils.lerp(card.rotation.y, Math.PI + mouse.x * 0.5, 0.1);
                card.scale.lerp(new THREE.Vector3(2.0, 2.0, 2.0), 0.1);
            }
        } else {
            // å…¶ä»–ç‰Œå¤ä½
            card.position.lerp(card.userData.basePos, 0.1);
            card.rotation.y = THREE.MathUtils.lerp(card.rotation.y, Math.PI, 0.1);
            card.rotation.z = THREE.MathUtils.lerp(card.rotation.z, 0, 0.1);
            card.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1); // é»˜è®¤æ›´å°ï¼Œçªå‡ºè¢«æŠ“å–çš„ç‰Œ
        }
    }

    // ç²’å­æ›´æ–°
    if (particles) updateParticles();
    
    renderer.render(scene, camera);
}

// ä¼˜åŒ–çš„æ‰‹åŠ¿é€»è¾‘ï¼šä½¿ç”¨æ—¶é—´åˆ¤æ–­
function checkGesture(isOpen, isPinching) {
    const txt = document.getElementById('gesture-txt');
    const dot = document.getElementById('hand-dot');

    // 1. æ›´æ–°æ‰‹éƒ¨åœ†ç‚¹é¢œè‰²
    if (isPinching) handCursor.material.color.setHex(0x00ffaa); // ç»¿è‰²è¡¨ç¤ºæä½
    else handCursor.material.color.setHex(0xffd700); // é‡‘è‰²è¡¨ç¤ºå¼ å¼€

    // 2. çŠ¶æ€æœº
    if (appState === 'IDLE' && isFlowActive) {
        if (isPinching) {
            // å°„çº¿æ£€æµ‹
            const intersect = raycaster.intersectObjects(cards);
            if (intersect.length > 0) {
                grabbedCard = intersect[0].object;
                appState = 'GRABBING';
                pinchStartTime = Date.now(); // å¼€å§‹è®¡æ—¶
                txt.innerText = "âš¡ å……èƒ½ä¸­...";
            }
        } else {
            txt.innerText = "ğŸ– æä½ç‰Œ";
        }
    } 
    else if (appState === 'GRABBING') {
        if (isPinching) {
            // è®¡ç®—æä½æ—¶é—´
            const duration = Date.now() - pinchStartTime;
            const progress = Math.min(duration / CONFIG.holdTimeRequired, 1.0);
            
            // ç®€å•çš„è¿›åº¦åé¦ˆ
            const percent = Math.floor(progress * 100);
            txt.innerText = `âš¡ å……èƒ½ ${percent}%`;
            
            // æä½æ—¶é—´å¤Ÿäº†ï¼Œè‡ªåŠ¨è§¦å‘
            if (duration > CONFIG.holdTimeRequired) {
                triggerReveal(grabbedCard);
            }
        } else {
            // ä¸­é€”æ¾æ‰‹ï¼Œå–æ¶ˆ
            appState = 'IDLE';
            grabbedCard = null;
            txt.innerText = "âŒ ä¸­æ–­";
        }
    }
    else if (appState === 'REVEALED') {
        // å¦‚æœæ˜¯å·²æ­ç¤ºçŠ¶æ€ï¼Œå¼ å¼€æ‰‹æŒè§¦å‘æ¶ˆæ•£
        if (isOpen) {
            createSilverDissolve(grabbedCard);
        } else {
            txt.innerText = "ğŸ– å¼ æ‰‹é‡Šæ”¾";
        }
    }
}

function triggerReveal(card) {
    if (!card || appState !== 'GRABBING') return;
    
    appState = 'REVEALED';
    
    const randomIndex = Math.floor(Math.random() * DECK_POOL.length);
    const randomData = DECK_POOL[randomIndex];
    
    card.userData.data = {
        ...randomData,
        isRev: Math.random() < 0.3,
        drawIndex: drawnCardsList.length 
    };
    
    // 1. ç«‹å³æ˜¾ç¤ºâ€œåŠ è½½ä¸­â€å›¾ç‰‡ï¼Œé¿å…é»‘å±
    if (loadingTexture) {
        card.material[4].map = loadingTexture;
        card.material[4].color.setHex(0xffffff);
        card.material[4].needsUpdate = true;
    }

    // 2. éšè— 3D ç‰Œï¼Œå‡†å¤‡æ˜¾ç¤º 2D å¼¹çª—
    // è¿™é‡Œåšä¸ªå°å»¶è¿Ÿï¼Œè®©ç”¨æˆ·çœ‹åˆ°ç‰Œç¿»è½¬çš„ä¸€ç¬é—´æ˜¯â€œåŠ è½½ä¸­â€çŠ¶æ€
    setTimeout(() => {
        card.visible = false;
        
        // 3. åå°é™é»˜åŠ è½½å¤§å›¾
        const safeUrl = CONFIG.cardsPath + encodeURIComponent(randomData.file);
        // æ˜¾ç¤ºæ¨¡æ€æ¡†ï¼Œå›¾ç‰‡ä½ç½®å…ˆæ”¾ loading å›¾ï¼Œæˆ–è€…ç›´æ¥å¼€å§‹åŠ è½½
        showModal(card.userData.data, safeUrl); 
    }, 200);
}

function showModal(data, finalImageUrl) {
    const modal = document.getElementById('card-modal');
    modal.innerHTML = ''; 

    // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
    const img = document.createElement('img');
    img.className = 'modal-card-img'; 
    // å…ˆæ˜¾ç¤ºåŠ è½½å›¾
    img.src = LOADING_IMG_URL;
    
    // å°è¯•åŠ è½½æœ€ç»ˆçš„é«˜æ¸…å›¾
    const downloadingImage = new Image();
    downloadingImage.onload = function(){
        img.src = this.src; // ä¸‹è½½å¥½äº†å†æ›¿æ¢
    };
    downloadingImage.onerror = function(){
        // å¤±è´¥äº†å°±ç”¨ç‰ŒèƒŒ
        img.src = BACK_IMG_URL;
    };
    downloadingImage.src = finalImageUrl;

    modal.appendChild(img);

    const h2 = document.createElement('h2');
    h2.innerText = data.zh + (data.isRev ? " (é€†ä½)" : "");
    modal.appendChild(h2);

    const p = document.createElement('p');
    // æ ¹æ® TAROT_DB è·å–ä¿¡æ¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç»™é»˜è®¤
    const dbInfo = TAROT_DB[data.zh] || TAROT_DB["DEFAULT"];
    p.innerText = `âœ¦ ${dbInfo.keywords}`;
    modal.appendChild(p);

    modal.classList.add('active');
    document.getElementById('hint').style.opacity = 0;
}

// ç²’å­ç‰¹æ•ˆ (ç®€åŒ–ç‰ˆ)
function updateParticles() {
    const positions = particles.geometry.attributes.position.array;
    for (let i = 0; i < positions.length; i += 3) {
        positions[i+1] += 0.05; // ç®€å•å‘ä¸Šé£˜
        if (positions[i+1] > 5) positions[i+1] = -5; // å¾ªç¯
    }
    particles.geometry.attributes.position.needsUpdate = true;
}

function createSilverDissolve(mesh) {
    if (!mesh) return;
    appState = 'DISSOLVING';
    drawnCardsList.push(mesh.userData.data);
    
    document.getElementById('card-modal').classList.remove('active');
    
    // ç®€å•åšä¸€ä¸ªæ¶ˆå¤±æ•ˆæœï¼Œä¸å†ç”Ÿæˆå¤§é‡ç²’å­ï¼ŒèŠ‚çœæ‰‹æœºæ€§èƒ½
    mesh.visible = true;
    mesh.scale.set(0,0,0); // ç¬é—´ç¼©å°æ¶ˆå¤±
    
    setTimeout(() => {
        mesh.scale.set(1,1,1);
        mesh.material[4].color.setHex(0x000000); // å˜å›é»‘åº•
        if (backTexture) mesh.material[5].map = backTexture; // ç¡®ä¿èƒŒé¢æ˜¯å›¾
        grabbedCard = null;

        if (drawnCardsList.length >= currentMode) {
            appState = 'FINISHED';
            showFinalResult();
        } else {
            appState = 'IDLE';
            document.getElementById('hint').style.opacity = 1;
            document.getElementById('gesture-txt').innerText = `æŠ½å–ç¬¬ ${drawnCardsList.length + 1} å¼ `;
        }
    }, 800); 
}

// å¯åŠ¨æ‘„åƒå¤´ (ç§»åŠ¨ç«¯ä¼˜åŒ–)
async function startCamera() {
    const video = document.getElementById('webcam');
    
    // æ£€æŸ¥ HTTPS
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        alert("âš ï¸ æ‰‹æœºç«¯å¿…é¡»ä½¿ç”¨ HTTPS åè®®æ‰èƒ½æ‰“å¼€æ‘„åƒå¤´ï¼");
        return;
    }

    const HandsClass = window.Hands || (window.mpHands ? window.mpHands.Hands : null) || (window.google ? window.google.mediapipe.hands.Hands : null);
    if (!HandsClass) { alert("èµ„æºåŠ è½½ä¸­ï¼Œè¯·ç¨åå†è¯•..."); return; }
    if (isMediaPipeReady) return;

    document.getElementById('btn-cam').innerText = "â³ å¯åŠ¨ä¸­...";
    
    try {
        const hands = new HandsClass({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        // é™ä½æ¨¡å‹å¤æ‚åº¦ï¼Œç”¨ lite æ¨¡å‹
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onHandResults);

        const CameraClass = window.Camera || (window.mpCamera ? window.mpCamera.Camera : null);
        const cameraHelper = new CameraClass(video, { 
            onFrame: async () => { if (video.readyState >= 2) await hands.send({image: video}); }, 
            width: 640, height: 480, // é™ä½åˆ†è¾¨ç‡æé€Ÿ
            facingMode: 'user'
        });

        await cameraHelper.start();
        isMediaPipeReady = true;
        document.getElementById('video-container').classList.add('active');
        document.getElementById('btn-cam').innerText = "ğŸ“· å·²å¼€å¯";
    } catch (e) {
        alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + e.message);
        document.getElementById('btn-cam').innerText = "âŒ å¤±è´¥";
    }
}

function onHandResults(results) {
    if (!document.getElementById('mode-selection').classList.contains('hidden') || document.getElementById('result-overlay').classList.contains('active')) return;

    const dot = document.getElementById('hand-dot');
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        dot.classList.add('active');
        const lm = results.multiHandLandmarks[0];
        
        // æ˜ å°„åæ ‡
        targetMouse.x = (1 - lm[8].x) * 2 - 1;
        targetMouse.y = -(lm[8].y * 2 - 1);

        // ç®€å•çš„æåˆæ£€æµ‹
        const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
        const isPinching = dist < CONFIG.pinchThreshold; 
        const isOpen = !isPinching;

        // æ‰§è¡Œç»Ÿä¸€çš„æ‰‹åŠ¿é€»è¾‘
        checkGesture(isOpen, isPinching);

    } else {
        dot.classList.remove('active');
        document.getElementById('gesture-txt').innerText = "å¯»è§…ä¸­...";
        isPinching = false;
        pinchStartTime = 0;
    }
}

// è¾…åŠ©å‡½æ•°
function selectMode(mode) { currentMode = mode; drawnCardsList = []; isFlowActive = true; appState = 'IDLE'; document.getElementById('mode-selection').classList.add('hidden'); document.getElementById('hint').style.opacity = 1; }
function resetApp() { document.getElementById('result-overlay').classList.remove('active'); document.getElementById('mode-selection').classList.remove('hidden'); appState = 'IDLE'; }
function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
function showFinalResult() { 
    document.getElementById('card-modal').classList.remove('active');
    const container = document.getElementById('result-cards');
    const textArea = document.getElementById('result-text');
    container.innerHTML = '';
    
    drawnCardsList.forEach((card, i) => {
        const div = document.createElement('div');
        div.className = 'mini-card';
        div.style.animationDelay = `${i*0.1}s`;
        const url = CONFIG.cardsPath + encodeURIComponent(card.file);
        div.innerHTML = `<div class="pos-label">${i+1}</div><img src="${url}"><div class="name-label">${card.zh}</div>`;
        container.appendChild(div);
    });
    
    let html = "";
    drawnCardsList.forEach((c, i) => {
        const info = TAROT_DB[c.zh] || TAROT_DB["DEFAULT"];
        html += `<div class="interp-section"><div class="interp-title">${c.zh} ${c.isRev?"(é€†)":""}</div><div class="interp-content">${info.poison}</div></div>`;
    });
    textArea.innerHTML = html;
    document.getElementById('result-overlay').classList.add('active');
}

// ç»‘å®šäº‹ä»¶
document.getElementById('btn-cam').onclick = startCamera;
const btnFull = document.getElementById('btn-full');
btnFull.onclick = () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else if (document.exitFullscreen) document.exitFullscreen(); };
window.addEventListener('load', initScene);

</script>
</body>
</html>
