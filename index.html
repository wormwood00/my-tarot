<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Mystic Tarot - Universal Fix</title>
    <style>
        /* æ ·å¼ä¿æŒåŸæ · */
        :root { --gold: #ffd700; --gold-glow: rgba(255, 215, 0, 0.5); --bg-dark: #050510; }
        body { margin: 0; overflow: hidden; background: var(--bg-dark); font-family: 'Noto Sans SC', sans-serif; color: white; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 60; pointer-events: none; }
        .hud { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: auto; }
        .badge { background: rgba(20, 20, 35, 0.8); border: 1px solid rgba(255, 215, 0, 0.3); color: var(--gold); padding: 8px 16px; border-radius: 50px; font-size: 12px; display: flex; align-items: center; gap: 6px; backdrop-filter: blur(5px); }
        .status-dot { width: 8px; height: 8px; background: #555; border-radius: 50%; transition: 0.3s; }
        .status-dot.active { background: #00ffaa; box-shadow: 0 0 10px #00ffaa; }
        #mode-selection { position: absolute; inset: 0; background: rgba(5, 5, 16, 0.95); z-index: 50; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: 0.3s; pointer-events: auto; }
        #mode-selection.hidden { opacity: 0; pointer-events: none; transform: scale(1.1); }
        .mode-title { color: var(--gold); font-size: 22px; letter-spacing: 3px; margin-bottom: 30px; text-shadow: 0 0 10px var(--gold-glow); }
        .mode-container { display: flex; flex-direction: column; gap: 15px; width: 80%; max-width: 300px; }
        .mode-card { background: rgba(30,30,40,0.8); border: 1px solid rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 12px; }
        #result-overlay { position: absolute; inset: 0; background: rgba(5,5,10,0.98); z-index: 100; display: none; flex-direction: column; padding: 30px 20px; overflow-y: auto; }
        #result-overlay.active { display: flex; }
        .result-header { text-align: center; margin-bottom: 30px; }
        .cards-spread { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 30px; }
        .mini-card { width: 90px; text-align: center; }
        .mini-card img { width: 100%; border-radius: 6px; border: 1px solid #333; }
        #video-container { position: absolute; top: 60px; right: 20px; width: 100px; height: 130px; border-radius: 8px; overflow: hidden; opacity: 0; transition: 0.5s; z-index: 5; border: 1px solid var(--gold); }
        #video-container.active { opacity: 0.8; }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        .modal-card-img { max-width: 80vw; max-height: 60vh; border-radius: 10px; border: 2px solid var(--gold); box-shadow: 0 0 30px var(--gold-glow); margin-bottom: 20px; }
        #card-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; text-align: center; pointer-events: none; z-index: 20; opacity: 0; transition: 0.3s; }
        #card-modal.active { opacity: 1; pointer-events: auto; }
        #loading { position: fixed; inset: 0; background: #020205; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        #hint { position: absolute; top: 55%; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 12px; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

<div id="loading">
    <div class="spinner" style="width:40px; height:40px; border:2px solid #333; border-top-color:#ffd700; border-radius:50%; animation:spin 1s linear infinite;"></div>
    <p style="margin-top: 20px; color: #ffd700; font-size: 12px;">è§‰é†’ä»ªå¼ä¸­...</p>
</div>

<div id="mode-selection" class="hidden">
    <div class="mode-title">é€‰æ‹©å¯ç¤ºæ¨¡å¼</div>
    <div class="mode-container">
        <div class="mode-card" onclick="selectMode(1)"><h3>âœ¨ æ¯æ—¥ä¸€æŠ½</h3><p>ä»Šæ—¥æŒ‡å¼•</p></div>
        <div class="mode-card" onclick="selectMode(3)"><h3>â³ ä¸‰ç‰Œé˜µ</h3><p>æ—¶é—´æµå‘</p></div>
        <div class="mode-card" onclick="selectMode(5)"><h3>âš–ï¸ å†³ç­–å¯¹æ¯”</h3><p>æŠ‰æ‹©åˆ†æ</p></div>
    </div>
</div>

<div id="result-overlay">
    <div class="result-header"><h2 id="res-t">æ˜Ÿç•Œå¯ç¤ºå½•</h2></div>
    <div class="cards-spread" id="result-cards"></div>
    <div class="interpretation-box" id="result-text"></div>
    <button class="badge" style="margin: 20px auto; pointer-events: auto;" onclick="resetApp()">å†æ¬¡æé—®</button>
</div>

<div id="ui-layer">
    <div class="hud">
        <div class="btn-group"><div class="badge" id="btn-cam" style="pointer-events: auto;">ğŸ“· å¯åŠ¨çµè§†</div></div>
        <div class="badge">
            <div class="status-dot" id="hand-dot"></div>
            <span id="gesture-txt">å¯»è§…ä¸­...</span>
        </div>
    </div>
    <div id="card-modal"></div>
    <div id="hint" style="opacity: 0">æ‰‹åŠ¿è¯†åˆ«å¼€å¯ï¼Œæˆ–ç›´æ¥ã€ç‚¹å‡»ã€‘å¡ç‰Œ</div>
</div>

<div id="video-container"><video id="webcam" playsinline webkit-playsinline muted></video></div>

<script>
// --- æ ¸å¿ƒé€»è¾‘ ---
const REMOTE_PATH = "https://fastly.jsdelivr.net/gh/wormwood00/my-tarot@main/";
const BACK_IMG_URL = "https://fastly.jsdelivr.net/gh/wormwood00/my-tarot@main/1767441720.png";
const LOADING_IMG_URL = "https://fastly.jsdelivr.net/gh/wormwood00/my-tarot@main/%E5%8A%A0%E8%BD%BD%E4%B8%AD%E7%89%8C%E9%9D%A2.png";

const SPECIAL_FILENAMES = { "å¥³ç¥­å¸": "å¥³ç¥­å¸-å¡”ç½—ç‰Œ.jpg", "å¥³çš‡": "å¥³çš‡-å¡”ç½—ç‰Œ.jpg", "çš‡å¸": "çš‡å¸å¡”ç½—ç‰Œç‚¹è§£.jpg", "æ•™çš‡": "æ•™çš‡å¡”ç½—ç‰Œ.jpg", "æ‹äºº": "æ‹äººå¡”ç½—ç‰Œ.jpg" };
const MAJOR_ORDER = ["æ„šè€…","é­”æœ¯å¸ˆ","å¥³ç¥­å¸","å¥³çš‡","çš‡å¸","æ•™çš‡","æ‹äºº","æˆ˜è½¦","åŠ›é‡","éšå£«","å‘½è¿ä¹‹è½®","æ­£ä¹‰","å€’åŠäºº","æ­»ç¥","èŠ‚åˆ¶","æ¶é­”","é«˜å¡”","æ˜Ÿæ˜Ÿ","æœˆäº®","å¤ªé˜³","å®¡åˆ¤","ä¸–ç•Œ"];
const MINOR_RANKS = ["é¦–ç‰Œ", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹", "å", "ä¾ä»", "éª‘å£«", "çš‡å", "å›½ç‹"];

function getFileName(zhName) { return SPECIAL_FILENAMES[zhName] || (zhName + ".jpg"); }
function buildDeckPool() {
    let deck = [];
    MAJOR_ORDER.forEach(name => deck.push({ zh: name, type: 'å¤§é˜¿å¡çº³', file: getFileName(name) }));
    ["æƒæ–", "åœ£æ¯", "å®å‰‘", "æ˜Ÿå¸"].forEach(suit => {
        MINOR_RANKS.forEach(rank => deck.push({ zh: suit+rank, type: 'å°é˜¿å¡çº³', file: getFileName(suit+rank) }));
    });
    return deck;
}
const DECK_POOL = buildDeckPool();

let scene, camera, renderer, raycaster, deckGroup, cards = [];
let targetMouse = new THREE.Vector2(), mouse = new THREE.Vector2(-999, -999);
let appState = 'LOADING', drawnCardsList = [], currentMode = 0;
let grabbedCard = null, pinchStartTime = 0, isMediaPipeReady = false;
let loadingTexture, backTexture;

function initScene() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.z = 25;
    renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);

    const loader = new THREE.TextureLoader();
    loader.load(BACK_IMG_URL, tex => { backTexture = tex; cards.forEach(c => c.material[5].map = tex); });
    loader.load(LOADING_IMG_URL, tex => loadingTexture = tex);

    deckGroup = new THREE.Group();
    const cardGeo = new THREE.BoxGeometry(3.2, 4.8, 0.1);
    for(let i=0; i<78; i++) {
        const mats = [
            new THREE.MeshBasicMaterial({color:0x111}), new THREE.MeshBasicMaterial({color:0x111}),
            new THREE.MeshBasicMaterial({color:0x111}), new THREE.MeshBasicMaterial({color:0x111}),
            new THREE.MeshBasicMaterial({color:0x000}), new THREE.MeshStandardMaterial({color:0x444466})
        ];
        const card = new THREE.Mesh(cardGeo, mats);
        card.position.x = (i - 39) * 4.5;
        card.rotation.y = Math.PI;
        card.userData = { basePos: card.position.clone() };
        deckGroup.add(card);
        cards.push(card);
    }
    scene.add(deckGroup);
    scene.add(new THREE.AmbientLight(0xffffff, 1));
    raycaster = new THREE.Raycaster();

    // å¢åŠ è§¦å±äº¤äº’å…œåº•
    window.addEventListener('touchstart', onTouchStart, { passive: false });
    animate();

    setTimeout(() => { 
        document.getElementById('loading').style.display='none'; 
        document.getElementById('mode-selection').classList.remove('hidden');
    }, 1500);
}

function onTouchStart(e) {
    if (appState !== 'IDLE') return;
    const touch = e.touches[0];
    const tapX = (touch.clientX / window.innerWidth) * 2 - 1;
    const tapY = -(touch.clientY / window.innerHeight) * 2 + 1;
    mouse.set(tapX, tapY);
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(cards);
    if (intersects.length > 0) {
        grabbedCard = intersects[0].object;
        triggerReveal(grabbedCard);
    }
}

function animate() {
    requestAnimationFrame(animate);
    mouse.lerp(targetMouse, 0.2);
    if (appState === 'IDLE') deckGroup.position.x = THREE.MathUtils.lerp(deckGroup.position.x, -mouse.x * 100, 0.05);
    cards.forEach(card => {
        if (card === grabbedCard && appState === 'GRABBING') {
            card.scale.lerp(new THREE.Vector3(2, 2, 2), 0.1);
            card.position.lerp(new THREE.Vector3(0, 0, 15), 0.1);
        } else {
            card.position.lerp(card.userData.basePos, 0.1);
            card.scale.lerp(new THREE.Vector3(0.7, 0.7, 0.7), 0.1);
        }
    });
    renderer.render(scene, camera);
}

function triggerReveal(card) {
    appState = 'REVEALED';
    const data = DECK_POOL[Math.floor(Math.random() * DECK_POOL.length)];
    card.userData.data = { ...data, isRev: Math.random() < 0.3 };
    card.visible = false;
    showModal(card.userData.data, REMOTE_PATH + encodeURIComponent(data.file));
}

function showModal(data, url) {
    const modal = document.getElementById('card-modal');
    modal.innerHTML = `<img src="${LOADING_IMG_URL}" id="m-img" class="modal-card-img"><h2>${data.zh}${data.isRev?' (é€†ä½)':''}</h2><p>âœ¦ ç‚¹å‡»å¡ç‰Œæˆ–å¼ æ‰‹ç»§ç»­</p>`;
    const img = modal.querySelector('#m-img');
    const loadReal = new Image();
    loadReal.onload = () => img.src = url;
    loadReal.src = url;
    modal.classList.add('active');
    document.getElementById('hint').style.opacity = 1;
    // æ‰‹æœºç‚¹å‡»å¼¹çª—å›¾ç‰‡ä¹Ÿèƒ½æ¶ˆæ•£
    modal.onclick = () => createSilverDissolve(grabbedCard);
}

function createSilverDissolve(mesh) {
    drawnCardsList.push(mesh.userData.data);
    document.getElementById('card-modal').classList.remove('active');
    appState = (drawnCardsList.length >= currentMode) ? 'FINISHED' : 'IDLE';
    if (appState === 'FINISHED') showFinalResult();
    grabbedCard = null;
}

async function startCamera() {
    const video = document.getElementById('webcam');
    try {
        const CameraClass = window.Camera;
        const HandsClass = window.Hands;
        const hands = new HandsClass({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });
        hands.onResults(results => {
            const txt = document.getElementById('gesture-txt');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('hand-dot').classList.add('active');
                const lm = results.multiHandLandmarks[0];
                targetMouse.x = (1 - lm[8].x) * 2 - 1;
                targetMouse.y = -(lm[8].y * 2 - 1);
                const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if (appState === 'IDLE' && dist < 0.05) {
                    raycaster.setFromCamera(targetMouse, camera);
                    const isects = raycaster.intersectObjects(cards);
                    if (isects.length > 0) { grabbedCard = isects[0].object; triggerReveal(grabbedCard); }
                }
                if (appState === 'REVEALED' && dist > 0.1) createSilverDissolve(grabbedCard);
                txt.innerText = "çµè§†å·²å¯";
            } else {
                document.getElementById('hand-dot').classList.remove('active');
                txt.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
            }
        });
        new CameraClass(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 640 }).start();
        document.getElementById('video-container').classList.add('active');
        isMediaPipeReady = true;
    } catch (e) { alert("æ‘„åƒå¤´è¯†åˆ«æ¨¡å‹å¯åŠ¨å¤±è´¥ï¼Œè¯·ç›´æ¥ç‚¹å‡»å¡ç‰Œæ¸¸ç©ã€‚"); }
}

function selectMode(m) { currentMode = m; appState = 'IDLE'; isFlowActive = true; document.getElementById('mode-selection').classList.add('hidden'); document.getElementById('hint').style.opacity = 1; }
function resetApp() { location.reload(); }
function showFinalResult() {
    const ov = document.getElementById('result-overlay');
    const resC = document.getElementById('result-cards');
    resC.innerHTML = '';
    drawnCardsList.forEach(c => {
        resC.innerHTML += `<div class="mini-card"><img src="${REMOTE_PATH}${encodeURIComponent(c.file)}"><p>${c.zh}</p></div>`;
    });
    ov.classList.add('active');
}
document.getElementById('btn-cam').onclick = startCamera;
window.onload = initScene;
</script>
</body>
</html>
